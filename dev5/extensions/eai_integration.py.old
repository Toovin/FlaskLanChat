# extensions/eai_integration.py

import requests
import base64
import os
import json
import aiohttp
import asyncio
from datetime import datetime
from pathlib import Path

def setup(command_processor):
    """Setup function to register the @eai command with the CommandProcessor."""
    # Load config
    config_path = os.path.join(os.path.dirname(__file__), '..', 'eai_config.json')
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)
        print(f"EAI config loaded: {config}")
    except FileNotFoundError:
        config = {
            'eai_api_url': 'http://172.28.176.1:12340/v1/chat/completions',
            'bot_mention': '@eai',
            'max_tokens': 1000,
            'temperature': 0.7,
            'supported_image_formats': ['.png', '.jpg', '.jpeg', '.gif'],
            'default_instruction': 'You are a helpful assistant named EAI, providing clear and concise responses.'
        }
        print("EAI config file not found, using defaults")

    eai_api_url = config.get('eai_api_url')
    bot_mention = config.get('bot_mention')
    max_tokens = config.get('max_tokens')
    temperature = config.get('temperature')
    supported_image_formats = config.get('supported_image_formats')
    default_instruction = config.get('default_instruction')

    async def download_attachment(url, as_base64=False):
        """Download an attachment and return its content as base64 or text."""
        print(f"Downloading attachment: {url}, as_base64={as_base64}")
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as resp:
                    if resp.status != 200:
                        print(f"Failed to download attachment {url}: Status {resp.status}")
                        return None
                    content_type = resp.headers.get('content-type', 'text/plain')
                    if as_base64:
                        content = await resp.read()
                        base64_content = base64.b64encode(content).decode('utf-8')
                        return f"data:{content_type};base64,{base64_content}"
                    else:
                        content = await resp.text()
                        return content
        except Exception as e:
            print(f"Error downloading attachment {url}: {e}")
            return None

    async def process_attachments(attachments):
        """Process attachments, separating images and text files."""
        print(f"Processing attachments: {attachments}")
        image_urls = []
        text_content = []
        for attachment in attachments:
            ext = os.path.splitext(attachment['filename'])[1].lower()
            if ext in supported_image_formats:
                base64_image = await download_attachment(attachment['url'], as_base64=True)
                if base64_image:
                    image_urls.append(base64_image)
            else:
                content = await download_attachment(attachment['url'], as_base64=False)
                if content:
                    text_content.append({
                        'filename': attachment['filename'],
                        'content': content
                    })
        print(f"Processed attachments - Images: {len(image_urls)}, Text: {len(text_content)}")
        return image_urls, text_content

    def eai_command(args, sender, channel, form_data=None, initial_prompt=''):
        """Handle @eai mentions for text or vision-based chat."""
        print(f"EAI command called with args: {args}, sender: {sender}, channel: {channel}, form_data: {form_data}, initial_prompt: {initial_prompt}")
        # Extract message content
        message = args if isinstance(args, str) else (form_data.get('message', '') if form_data else '')
        if not message:
            print("No message content provided")
            return None

        # Check if the message starts with the bot mention or !eai
        if not (message.startswith(bot_mention) or message.startswith('!eai')):
            print(f"Message does not start with {bot_mention} or !eai: {message}")
            return None

        # Normalize to @eai
        content = message
        if message.startswith('!eai'):
            content = f"{bot_mention} {message[4:].strip()}" if message[4:].strip() else bot_mention
        content = content[len(bot_mention):].strip()
        print(f"Normalized content: {content}")

        attachments = form_data.get('attachments', []) if form_data else []

        # Run async processing in the event loop
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            result = loop.run_until_complete(process_eai(content, attachments, sender, channel))
            print(f"EAI command result: {result}")
            return result
        except Exception as e:
            print(f"Error in eai_command: {e}")
            return {
                'sender': 'Bot',
                'message': f"Reeeee, something went wrong: {str(e)}",
                'is_media': False,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }
        finally:
            loop.close()

    async def process_eai(content, attachments, sender, channel):
        """Process the @eai command asynchronously."""
        print(f"Processing EAI with content: {content}, attachments: {attachments}, sender: {sender}, channel: {channel}")
        try:
            # Process attachments
            image_urls, text_content = await process_attachments(attachments)

            # Build the message payload
            messages = [
                {
                    'role': 'system',
                    'content': default_instruction
                }
            ]

            # Add text content from attachments
            if text_content:
                text_summary = '\n'.join(
                    f"[Attachment: {item['filename']}]\n{item['content']}"
                    for item in text_content
                )
                content += f"\n\nAttached files:\n{text_summary}"

            # Add user message
            user_content = [{'type': 'text', 'text': content or 'No text provided, only images.'}]
            if image_urls:
                user_content.extend([{'type': 'image_url', 'image_url': {'url': url}} for url in image_urls])

            messages.append({
                'role': 'user',
                'content': user_content
            })

            # Prepare API payload
            payload = {
                'messages': messages,
                'max_tokens': max_tokens,
                'temperature': temperature
            }
            print(f"Sending API request with payload: {payload}")

            # Send request to LMStudio
            async with aiohttp.ClientSession() as session:
                async with session.post(eai_api_url, json=payload, timeout=30) as response:
                    print(f"API response status: {response.status}")
                    if response.status != 200:
                        return {
                            'sender': 'Bot',
                            'message': f"Reeeee, API request failed: {response.status}",
                            'is_media': False,
                            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                        }
                    result = await response.json()
                    reply = result['choices'][0]['message']['content'].strip()
                    print(f"API response: {reply}")

            # Return text response
            return {
                'sender': 'Bot',
                'message': reply,
                'is_media': False,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }

        except Exception as e:
            print(f"Error processing @eai command: {e}")
            return {
                'sender': 'Bot',
                'message': f"Reeeee, something went wrong: {str(e)}",
                'is_media': False,
                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            }

    # Register the command
    command_processor.register_command('eai', eai_command)
    print("EAI command registered")

    # Modify CommandProcessor to handle @eai without requiring ! prefix
    original_process_command = command_processor.process_command

    def custom_process_command(data, user_uuid):
        message = data.get('message', '').strip()
        print(f"Custom process_command called with message: {message}, user_uuid: {user_uuid}")
        if message.startswith(bot_mention) or message.startswith('!eai'):
            print(f"Detected @eai or !eai command: {message}")
            if message.startswith('!eai'):
                data['message'] = f"{bot_mention} {message[4:].strip()}" if message[4:].strip() else bot_mention
            return original_process_command(data, user_uuid)
        print(f"Passing through to original process_command: {message}")
        return original_process_command(data, user_uuid)
    command_processor.process_command = custom_process_command
    print("Custom process_command overridden for @eai")